// Generated by CoffeeScript 1.4.0
(function() {
  var Backbone, Confines, Portion, Representation, TrigonLords, Zodiac, degrees, nestCollection, polyglot, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  Backbone = require('backbone-rel');

  degrees = require('upon').degrees;

  polyglot = require('there').polyglot;

  nestCollection = require('./nest-collection');

  Portion = (function(_super) {

    __extends(Portion, _super);

    function Portion() {
      return Portion.__super__.constructor.apply(this, arguments);
    }

    return Portion;

  })(Backbone.RelationalModel);

  TrigonLords = (function(_super) {

    __extends(TrigonLords, _super);

    function TrigonLords() {
      return TrigonLords.__super__.constructor.apply(this, arguments);
    }

    TrigonLords.prototype.initialize = function(attributes, representation) {
      this.attributes = attributes;
      this.representation = representation;
    };

    TrigonLords.prototype.dispositor = function(id) {
      return this.representation.collection.cosmos.ensemble.get(id);
    };

    TrigonLords.prototype.day = function() {
      return this.dispositor(this.get('D').get('lord'));
    };

    TrigonLords.prototype.night = function() {
      return this.dispositor(this.get('N').get('lord'));
    };

    TrigonLords.prototype.cooperating = function() {
      return this.dispositor(this.get('C').get('lord'));
    };

    return TrigonLords;

  })(Backbone.Collection);

  Confines = (function(_super) {

    __extends(Confines, _super);

    function Confines() {
      return Confines.__super__.constructor.apply(this, arguments);
    }

    Confines.prototype.initialize = function(attributes, representation, scheme) {
      this.attributes = attributes;
      this.representation = representation;
      this.scheme = scheme != null ? scheme : (_.first(this.attributes)).scheme;
      return this.schemes = _.unique(_.pluck(this.attributes, 'scheme'));
    };

    Confines.prototype.dispositor = function(id) {
      return this.representation.collection.cosmos.ensemble.get(id);
    };

    Confines.prototype.variants = function(zodeg, schemes) {
      var dispositors, item, portion, results, _i, _len;
      if (schemes == null) {
        schemes = this.schemes;
      }
      portion = degrees.lon(zodeg[1], zodeg[0]).rep('top')[1];
      dispositors = {};
      results = this.filter(function(bounds) {
        return _.include(schemes, bounds.get('scheme')) && bounds.get('from') <= portion && bounds.get('till') >= portion;
      });
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        item = results[_i];
        dispositors[item.attributes.scheme] = this.dispositor(item.attributes.lord);
      }
      return dispositors;
    };

    Confines.prototype.followed = function(degrees, scheme) {
      if (scheme == null) {
        scheme = this.scheme;
      }
      return (this.variants(degrees, [scheme]))[scheme];
    };

    return Confines;

  })(Backbone.Collection);

  Representation = (function(_super) {

    __extends(Representation, _super);

    function Representation() {
      return Representation.__super__.constructor.apply(this, arguments);
    }

    Representation.prototype.domicile = function() {
      return this.collection.cosmos.ensemble.get(this.get("domicile"));
    };

    Representation.prototype.exaltation = function() {
      var _ref;
      return (_ref = this.collection.cosmos.ensemble.get(this.get("exaltation"))) != null ? _ref : this.collection.cosmos.ensemble.getNone();
    };

    Representation.prototype.initialize = function(attributes) {
      if (attributes.trigons != null) {
        this.trigons = new TrigonLords(this.get('trigons'), this);
        nestCollection(this, 'trigons', this.trigons);
      }
      if (attributes.confines != null) {
        this.confines = new Confines(this.get('confines'), this);
        return nestCollection(this, 'confines', this.confines);
      }
    };

    return Representation;

  })(Backbone.RelationalModel);

  Zodiac = (function(_super) {

    __extends(Zodiac, _super);

    function Zodiac() {
      return Zodiac.__super__.constructor.apply(this, arguments);
    }

    Zodiac.prototype.model = Representation;

    Zodiac.prototype.zoidia = {
      the: [['PI'], ['AR'], ['TA'], ['GE'], ['CN'], ['LE'], ['VI'], ['LI'], ['SC'], ['SG'], ['CP'], ['AQ']],
      attributes: {
        key: "id",
        use: {
          id: 0,
          idz: 1,
          name: null
        }
      }
    };

    Zodiac.prototype.words = {
      expect: ["name"],
      filler: ["id"],
      data: {
        "AR": {
          name: {
            en: ["Ram", "Aries"],
            el: [true, "Κριός"],
            bg: [true, "Овен"]
          }
        },
        "TA": {
          name: {
            en: ["Bull", "Taurus"],
            el: [true, "Ταῦρος"],
            bg: [true, "Телец"]
          }
        },
        "GE": {
          name: {
            en: ["Twins", "Gemini"],
            el: [true, "Δίδυμοι"],
            bg: [true, "Близнаци"]
          }
        },
        "CN": {
          name: {
            en: ["Crab", "Cancer"],
            el: [true, "Καρκίνος"],
            bg: [true, "Рак"]
          }
        },
        "LE": {
          name: {
            en: ["Lion", "Leo"],
            el: [true, "Λέων"],
            bg: [true, "Лъв"]
          }
        },
        "VI": {
          name: {
            en: ["Virgin", "Virgo"],
            el: [true, "Παρθένος"],
            bg: [true, "Дева"]
          }
        },
        "LI": {
          name: {
            en: ["Balance", "Libra"],
            el: [true, "Ζυγός"],
            bg: [true, "Везни"]
          }
        },
        "SC": {
          name: {
            en: ["Scorpion", "Scoprio"],
            el: [true, "Σκορπίος"],
            bg: [true, "Скорпион"]
          }
        },
        "SG": {
          name: {
            en: ["Archer", "Sagittarius"],
            el: [true, "Τοξότης"],
            bg: [true, "Стрелец"]
          }
        },
        "CP": {
          name: {
            en: ["Goat-Horned", "Capricorn"],
            el: [true, "Ἀιγόκερως"],
            bg: [true, "Козирог"]
          }
        },
        "AQ": {
          name: {
            en: ["Water-Pourer", "Aquarius"],
            el: [true, "Φ̔δροχόος"],
            bg: [true, "Водолей"]
          }
        },
        "PI": {
          name: {
            en: ["Fishes", "Pisces"],
            el: [true, "Ἰχθύες"],
            bg: [true, "Риби"]
          }
        }
      }
    };

    Zodiac.prototype.all = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

    Zodiac.prototype.initialize = function(models, cosmos) {
      var attribute, i, position, z, _i, _j, _ref, _ref1;
      this.cosmos = cosmos;
      if (this.cosmos != null) {
        this.school = this.cosmos.school;
        this.language = this.cosmos.language;
      }
      for (i = _i = 0; _i <= 11; i = ++_i) {
        this.zoidia.the[i].push(i === 0 ? 12 : i);
      }
      _.extend(this, polyglot.ensure);
      if (!this.translatable([this.zoidia])) {
        throw "The zoidia can't be named!";
      }
      z = [];
      for (i = _j = 0, _ref = this.zoidia.the.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
        z.push({});
        _ref1 = this.zoidia.attributes.use;
        for (attribute in _ref1) {
          position = _ref1[attribute];
          z[i][attribute] = this.zoidia.the[i][position];
        }
        _.extend(z[i], models != null ? models[i] : void 0);
      }
      this.reset(z);
      return this;
    };

    Zodiac.prototype.id = function(idz) {
      return this.at(idz === 12 ? 0 : idz);
    };

    Zodiac.prototype.names = function(which) {
      var idz, names, _i, _len;
      if (which == null) {
        which = this.all;
      }
      if (!_.isArray(which)) {
        which = [which];
      }
      names = [];
      for (_i = 0, _len = which.length; _i < _len; _i++) {
        idz = which[_i];
        names.push(this.id(idz).get('name'));
      }
      return names;
    };

    Zodiac.prototype.idzF = function(idz, iterator) {
      if (idz == null) {
        idz = this.all;
      }
      if (!_.isArray(idz)) {
        idz = [idz];
      }
      return _.intersection(idz, _.filter(this.pluck('idz'), iterator));
    };

    Zodiac.prototype.female = function(idz) {
      return this.idzF(idz, function(z) {
        return z % 2 === 0;
      });
    };

    Zodiac.prototype.male = function(idz) {
      return this.idzF(idz, function(z) {
        return z % 2 === 1;
      });
    };

    Zodiac.prototype.confines = function(list, schemes) {
      var c, key, name, previous, results, several, value, where, _i, _len, _ref;
      results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        c = list[_i];
        several = {};
        previous = void 0;
        where = "" + c[0] + "," + c[1];
        several[where] = {};
        _ref = this.id(c[0]).confines.variants([c[0], c[1]]);
        for (key in _ref) {
          value = _ref[key];
          name = value.attributes.name;
          if (name !== previous) {
            several[where][name] = [key];
          } else {
            several[where][name].push(key);
          }
          previous = name;
        }
        results.push(several);
      }
      return results;
    };

    return Zodiac;

  })(Backbone.Collection);

  module.exports = Zodiac;

}).call(this);
